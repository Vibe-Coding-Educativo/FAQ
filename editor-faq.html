<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de FAQ para Docentes - Vibe Coding</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .tab-button.active {
            border-color: #4f46e5;
            color: #4f46e5;
            background-color: #eef2ff;
        }
        #loader {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(5px);
        }
        .log-entry {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <!-- Loader Overlay -->
    <div id="loader" class="fixed inset-0 z-50 flex-col items-center justify-center hidden">
        <div class="w-16 h-16 border-4 border-t-4 border-gray-200 border-t-indigo-600 rounded-full animate-spin"></div>
        <p id="loader-text" class="mt-4 text-lg font-medium text-indigo-600">Procesando...</p>
    </div>

    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-5xl">
        <header class="mb-6">
            <h1 class="text-3xl font-bold text-gray-900">Gestor de FAQ para Docentes</h1>
            <p class="text-md text-gray-600 mt-1">Añade y gestiona el contenido de la FAQ sobre Vibe Coding educativo.</p>
        </header>

        <!-- Tabs -->
        <div class="mb-6 border-b border-gray-200">
            <nav class="flex space-x-4" aria-label="Tabs">
                <button id="tab-btn-bulk" class="tab-button active whitespace-nowrap py-3 px-4 border-b-2 font-medium text-sm text-gray-500 hover:text-indigo-600 hover:border-indigo-300 focus:outline-none">
                    Añadir en bloque
                </button>
                <button id="tab-btn-single" class="tab-button whitespace-nowrap py-3 px-4 border-b-2 font-medium text-sm text-gray-500 hover:text-indigo-600 hover:border-indigo-300 focus:outline-none">
                    Añadir individualmente
                </button>
            </nav>
        </div>

        <!-- Tab Content -->
        <div>
            <!-- Bulk Add Tab -->
            <div id="tab-content-bulk">
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                    <h2 class="text-xl font-semibold mb-1">Añadir múltiples preguntas</h2>
                    <p class="text-gray-600 mb-4">Pega aquí el texto con las preguntas y respuestas. La IA las procesará, buscará duplicados y las añadirá a la hoja de cálculo. Formatos aceptados: "P: ... R: ..." o "Pregunta: ... Respuesta: ...".</p>
                    <textarea id="bulk-input" class="w-full h-64 p-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition" placeholder="P: ¿Cómo se inicia un proyecto en Vibe Coding?&#10;R: Para iniciar un proyecto, debes ir al menú Archivo y seleccionar 'Nuevo Proyecto'.&#10;&#10;Pregunta: ¿Qué son los 'sprites'?&#10;Respuesta: Los 'sprites' son los objetos o personajes que puedes programar en tu animación o juego."></textarea>
                    <button id="process-bulk-btn" class="mt-4 w-full sm:w-auto inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition">
                        Procesar y añadir
                    </button>
                </div>
                <div id="bulk-log" class="mt-6 bg-gray-900 text-white rounded-lg shadow-md p-4 font-mono text-sm max-h-80 overflow-y-auto">
                    <p class="text-gray-400">// Registro de actividad...</p>
                </div>
            </div>

            <!-- Single Add Tab -->
            <div id="tab-content-single" class="hidden">
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Input Column -->
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                        <h2 class="text-xl font-semibold mb-4">Añadir pregunta individual</h2>
                        <div class="space-y-4">
                            <div>
                                <label for="single-question" class="block text-sm font-medium text-gray-700">Pregunta</label>
                                <input type="text" id="single-question" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500">
                            </div>
                            <div>
                                <label for="single-answer" class="block text-sm font-medium text-gray-700">Respuesta</label>
                                <textarea id="single-answer" rows="5" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                            </div>
                            <button id="suggest-reformulation-btn" class="w-full sm:w-auto inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition">
                                Sugerir reformulación
                            </button>
                        </div>
                    </div>
                    <!-- Suggestion Column -->
                    <div id="suggestion-container" class="bg-white p-6 rounded-lg shadow-sm border border-gray-200 hidden">
                        <h2 class="text-xl font-semibold mb-4">Sugerencia de la IA</h2>
                        <p class="text-gray-600 mb-4">Revisa y edita las sugerencias. Una vez estés conforme, pulsa en "Aceptar y añadir".</p>
                        <div class="space-y-4">
                            <div>
                                <label for="suggested-question" class="block text-sm font-medium text-gray-700">Pregunta sugerida</label>
                                <input type="text" id="suggested-question" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 bg-indigo-50 focus:ring-indigo-500 focus:border-indigo-500">
                            </div>
                            <div>
                                <label for="suggested-answer" class="block text-sm font-medium text-gray-700">Respuesta sugerida</label>
                                <textarea id="suggested-answer" rows="5" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 bg-indigo-50 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                            </div>
                            <button id="accept-add-btn" class="w-full sm:w-auto inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition">
                                Aceptar y añadir a la FAQ
                            </button>
                        </div>
                         <div id="single-log" class="mt-4 text-sm text-center"></div>
                    </div>
                 </div>
            </div>
        </div>
    </div>

    <script type="module">
        // --- CONFIGURACIÓN ---
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbz3mmQ8cWOwExcbRfK8SLPrOlh8jIeybEzdLqLVZbISlJM6W14VGrVBkHxb93QLVVqUkg/exec';
        const GEMINI_MODEL = 'gemini-1.5-flash';

        // --- REFERENCIAS AL DOM ---
        const loader = document.getElementById('loader');
        const loaderText = document.getElementById('loader-text');
        
        const tabBtnBulk = document.getElementById('tab-btn-bulk');
        const tabBtnSingle = document.getElementById('tab-btn-single');
        const contentBulk = document.getElementById('tab-content-bulk');
        const contentSingle = document.getElementById('tab-content-single');

        const bulkInput = document.getElementById('bulk-input');
        const processBulkBtn = document.getElementById('process-bulk-btn');
        const bulkLog = document.getElementById('bulk-log');

        const singleQuestion = document.getElementById('single-question');
        const singleAnswer = document.getElementById('single-answer');
        const suggestBtn = document.getElementById('suggest-reformulation-btn');
        const suggestionContainer = document.getElementById('suggestion-container');
        const suggestedQuestion = document.getElementById('suggested-question');
        const suggestedAnswer = document.getElementById('suggested-answer');
        const acceptBtn = document.getElementById('accept-add-btn');
        const singleLog = document.getElementById('single-log');

        // --- ESTADO DE LA APLICACIÓN ---
        let apiKey = null;
        let faqData = [];
        let isLoading = false;

        // --- FUNCIONES DE LOG Y UI ---
        const showLoader = (show, text = 'Procesando...') => {
            isLoading = show;
            loaderText.textContent = text;
            loader.style.display = show ? 'flex' : 'hidden';
            if(show) {
                loader.classList.remove('hidden');
            } else {
                loader.classList.add('hidden');
            }
        };

        const logMessage = (logElement, message, type = 'info') => {
            const colors = {
                info: 'text-gray-300',
                success: 'text-green-400',
                error: 'text-red-400',
                warn: 'text-yellow-400'
            };
            const entry = document.createElement('p');
            entry.className = `log-entry ${colors[type]}`;
            entry.innerHTML = `<span class="mr-2">${new Date().toLocaleTimeString()}</span> > ${message}`;
            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight;
        };
        
        const logSingleMessage = (message, type = 'info') => {
            const colors = {
                info: 'text-gray-600',
                success: 'text-green-600',
                error: 'text-red-600',
            };
            singleLog.className = `mt-4 text-sm text-center ${colors[type]}`;
            singleLog.textContent = message;
        }

        const switchTab = (tabName) => {
            if (tabName === 'bulk') {
                contentBulk.classList.remove('hidden');
                contentSingle.classList.add('hidden');
                tabBtnBulk.classList.add('active');
                tabBtnSingle.classList.remove('active');
            } else {
                contentBulk.classList.add('hidden');
                contentSingle.classList.remove('hidden');
                tabBtnBulk.classList.remove('active');
                tabBtnSingle.classList.add('active');
            }
        };

        // --- COMUNICACIÓN CON GOOGLE APPS SCRIPT ---
        const fetchFromGoogleScript = async (action, payload = {}) => {
            try {
                // Usamos el método POST que es el que está definido en el script (doPost)
                const response = await fetch(SCRIPT_URL, {
                    method: 'POST',
                    mode: 'cors', // CORS es necesario para peticiones entre dominios
                    // Google Apps Script requiere que el payload esté como un string de texto plano
                    // en lugar de JSON, por eso no se usa la cabecera 'Content-Type': 'application/json'
                    body: JSON.stringify({ action, data: payload }),
                });

                if (!response.ok) {
                    throw new Error(`Error en la comunicación con el script: ${response.status} ${response.statusText}`);
                }
                // La respuesta del script es un JSON, por lo que la parseamos
                return await response.json();
            } catch (error) {
                console.error('Error en fetchFromGoogleScript:', error);
                logMessage(bulkLog, `Error de red: ${error.message}`, 'error');
                logSingleMessage(`Error de red: ${error.message}`, 'error');
                return null;
            }
        };
        
        // --- COMUNICACIÓN CON LA API DE GEMINI ---
        const callGemini = async (prompt, jsonSchema = null) => {
            if (!apiKey) {
                throw new Error("API Key de Gemini no disponible.");
            }
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
            };

            if (jsonSchema) {
                payload.generationConfig = {
                    responseMimeType: "application/json",
                    responseSchema: jsonSchema
                };
            }

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0) {
                    const content = result.candidates[0].content.parts[0].text;
                    return jsonSchema ? JSON.parse(content) : content;
                } else if (result.error) {
                    console.error("Error de la API de Gemini:", result.error);
                    throw new Error(`Error de la API de Gemini: ${result.error.message}`);
                }
                throw new Error("Respuesta inesperada de la API de Gemini.");
            } catch (error) {
                console.error('Error en callGemini:', error);
                throw error;
            }
        };

        // --- LÓGICA PRINCIPAL ---

        /**
         * Inicializa la aplicación: obtiene la API key y los datos de la FAQ.
         */
        const initialize = async () => {
            showLoader(true, 'Inicializando aplicación...');
            logMessage(bulkLog, 'Obteniendo API Key de Google Script...');
            const keyResponse = await fetchFromGoogleScript('getApiKey');
            if (keyResponse && keyResponse.status === 'success') {
                apiKey = keyResponse.apiKey;
                logMessage(bulkLog, 'API Key obtenida con éxito.', 'success');
            } else {
                const errorMessage = keyResponse ? keyResponse.message : 'Respuesta nula del script.';
                logMessage(bulkLog, `Fallo al obtener la API Key. ${errorMessage}`, 'error');
                showLoader(false);
                return;
            }

            logMessage(bulkLog, 'Cargando datos existentes de la FAQ...');
            await refreshFaqData();
            showLoader(false);
        };

        /**
         * Actualiza los datos de la FAQ desde la hoja de cálculo.
         */
        const refreshFaqData = async () => {
             logMessage(bulkLog, 'Leyendo la hoja de cálculo...', 'info');
             const dataResponse = await fetchFromGoogleScript('getData');
             if (dataResponse && dataResponse.status === 'success') {
                 faqData = dataResponse.data;
                 logMessage(bulkLog, `Se han cargado ${faqData.length} entradas de la FAQ.`, 'success');
             } else {
                 logMessage(bulkLog, 'No se pudieron cargar los datos de la FAQ o está vacía.', 'warn');
                 faqData = [];
             }
        };

        /**
         * Parsea el texto en bruto a un array de objetos {pregunta, respuesta}.
         */
        const parseBulkInput = (text) => {
            const pairs = [];
            const regex = /(?:P|Pregunta):\s*(.*?)\s*(?:R|Respuesta):\s*([\s\S]*?)(?=(?:P|Pregunta):|$)/gi;
            let match;
            while ((match = regex.exec(text)) !== null) {
                pairs.push({
                    pregunta: match[1].trim(),
                    respuesta: match[2].trim()
                });
            }
            return pairs;
        };
        
        /**
         * Comprueba si una pregunta es un duplicado semántico de las existentes.
         */
        const isSemanticDuplicate = async (newQuestion) => {
            if (faqData.length === 0) return false;

            const existingQuestions = faqData.map(item => item.pregunta);
            const prompt = `Eres un sistema experto en detectar duplicados semánticos en una base de conocimientos sobre programación educativa. Compara la "NUEVA PREGUNTA" con cada una de las "PREGUNTAS EXISTENTES". Si la nueva pregunta es esencialmente la misma que una existente (aunque esté formulada de otra manera), responde únicamente con la palabra "true". Si es una pregunta genuinamente nueva, responde únicamente con la palabra "false".

NUEVA PREGUNTA: "${newQuestion}"

PREGUNTAS EXISTENTES:
- ${existingQuestions.join('\n- ')}
`;
            const result = await callGemini(prompt);
            return result.toLowerCase().includes('true');
        };

        /**
         * Procesa el texto en bloque.
         */
        const handleBulkProcess = async () => {
            if (isLoading) return;
            const text = bulkInput.value.trim();
            if (!text) {
                logMessage(bulkLog, 'El área de texto está vacía.', 'warn');
                return;
            }

            showLoader(true, 'Procesando texto...');
            logMessage(bulkLog, 'Parseando preguntas y respuestas...');
            const parsedPairs = parseBulkInput(text);
            if (parsedPairs.length === 0) {
                logMessage(bulkLog, 'No se encontraron pares de pregunta/respuesta válidos.', 'error');
                showLoader(false);
                return;
            }
            logMessage(bulkLog, `Se han encontrado ${parsedPairs.length} pares.`, 'success');

            logMessage(bulkLog, 'Actualizando datos de la FAQ antes de comprobar duplicados...');
            showLoader(true, 'Actualizando datos...');
            await refreshFaqData();

            const nonDuplicates = [];
            for (const pair of parsedPairs) {
                showLoader(true, `Comprobando duplicado: "${pair.pregunta.substring(0, 30)}..."`);
                logMessage(bulkLog, `Comprobando duplicado semántico para: "${pair.pregunta}"`);
                const isDuplicate = await isSemanticDuplicate(pair.pregunta);
                if (isDuplicate) {
                    logMessage(bulkLog, `-> Duplicado encontrado. Se omitirá.`, 'warn');
                } else {
                    logMessage(bulkLog, `-> No es duplicado. Se procesará.`, 'success');
                    nonDuplicates.push(pair);
                }
            }

            if (nonDuplicates.length === 0) {
                logMessage(bulkLog, 'Todas las preguntas eran duplicados o no había preguntas nuevas.', 'info');
                showLoader(false);
                return;
            }

            showLoader(true, 'Generando categorías y palabras clave...');
            logMessage(bulkLog, `Enviando ${nonDuplicates.length} preguntas a la IA para su enriquecimiento...`);

            const existingCategories = [...new Set(faqData.flatMap(item => item.categorias || []))];
            const existingKeywords = [...new Set(faqData.flatMap(item => item.palabras_clave || []))];

            const prompt = `Eres un asistente experto en Vibe Coding educativo. Tu tarea es procesar una lista de preguntas y respuestas. Para cada una, debes generar categorías y palabras clave relevantes.
- Reutiliza las categorías existentes si es posible. Las categorías existentes son: [${existingCategories.join(', ')}].
- Reutiliza las palabras clave existentes si es posible. Las palabras clave existentes son: [${existingKeywords.join(', ')}].
- Crea nuevas categorías o palabras clave solo si es estrictamente necesario.
- Las categorías y palabras clave NO deben ser genéricas como "IA", "educación", "Vibe Coding", "pregunta", "respuesta". Deben ser específicas del contenido de la pregunta.
- Devuelve un array de objetos JSON.

Procesa las siguientes preguntas y respuestas:
${JSON.stringify(nonDuplicates, null, 2)}
`;

            const schema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        pregunta: { type: "STRING" },
                        respuesta: { type: "STRING" },
                        categorias: { type: "ARRAY", items: { type: "STRING" } },
                        palabras_clave: { type: "ARRAY", items: { type: "STRING" } }
                    },
                    required: ["pregunta", "respuesta", "categorias", "palabras_clave"]
                }
            };

            try {
                const processedData = await callGemini(prompt, schema);
                logMessage(bulkLog, 'Datos enriquecidos por la IA con éxito.', 'success');
                
                showLoader(true, `Añadiendo ${processedData.length} nuevas entradas...`);
                logMessage(bulkLog, `Añadiendo ${processedData.length} nuevas entradas a la hoja de cálculo...`);

                const addResponse = await fetchFromGoogleScript('addData', processedData);

                if (addResponse && addResponse.status === 'success') {
                    logMessage(bulkLog, `Éxito: ${addResponse.message}`, 'success');
                    bulkInput.value = ''; // Limpiar input
                } else {
                    logMessage(bulkLog, `Error al añadir datos: ${addResponse ? addResponse.message : 'Respuesta nula'}`, 'error');
                }
            } catch (error) {
                logMessage(bulkLog, `Error al procesar con IA: ${error.message}`, 'error');
            } finally {
                showLoader(false);
            }
        };
        
        /**
         * Pide a la IA una reformulación para una pregunta y respuesta individual.
         */
        const handleSuggestReformulation = async () => {
            if (isLoading) return;
            const question = singleQuestion.value.trim();
            const answer = singleAnswer.value.trim();

            if (!question || !answer) {
                logSingleMessage('Por favor, introduce una pregunta y una respuesta.', 'error');
                return;
            }
            
            showLoader(true, 'Generando sugerencia...');
            logSingleMessage('La IA está pensando en una mejor forma de explicarlo...', 'info');

            const prompt = `Eres un asistente experto en Vibe Coding para entornos educativos. Tu tarea es reformular una pregunta y una respuesta para que sean más claras, concisas y didácticas para docentes que no son expertos en programación. Evita la jerga técnica excesiva y enfócate en los conceptos pedagógicos y prácticos.

PREGUNTA ORIGINAL: "${question}"
RESPUESTA ORIGINAL: "${answer}"

Proporciona una versión reformulada.`;
            
            const schema = {
                type: "OBJECT",
                properties: {
                    pregunta_sugerida: {type: "STRING"},
                    respuesta_sugerida: {type: "STRING"}
                },
                required: ["pregunta_sugerida", "respuesta_sugerida"]
            };

            try {
                const suggestion = await callGemini(prompt, schema);
                suggestedQuestion.value = suggestion.pregunta_sugerida;
                suggestedAnswer.value = suggestion.respuesta_sugerida;
                suggestionContainer.classList.remove('hidden');
                logSingleMessage('Sugerencia generada. Puedes editarla antes de añadirla.', 'success');
            } catch(error) {
                logSingleMessage(`Error al generar sugerencia: ${error.message}`, 'error');
            } finally {
                showLoader(false);
            }
        };
        
        /**
         * Añade la pregunta individual (con su sugerencia) a la hoja de cálculo.
         */
        const handleAcceptAndAdd = async () => {
            if (isLoading) return;
            const question = suggestedQuestion.value.trim();
            const answer = suggestedAnswer.value.trim();

            if (!question || !answer) {
                logSingleMessage('La pregunta y respuesta sugeridas no pueden estar vacías.', 'error');
                return;
            }

            showLoader(true, 'Comprobando duplicados...');
            logSingleMessage('Comprobando duplicados semánticos...', 'info');
            
            await refreshFaqData();
            const isDuplicate = await isSemanticDuplicate(question);

            if (isDuplicate) {
                showLoader(false);
                logSingleMessage('Esta pregunta parece ser un duplicado de una ya existente.', 'error');
                return;
            }
            
            logSingleMessage('No es un duplicado. Generando categorías y palabras clave...', 'info');
            showLoader(true, 'Generando metadatos...');
            
            const existingCategories = [...new Set(faqData.flatMap(item => item.categorias || []))];
            const existingKeywords = [...new Set(faqData.flatMap(item => item.palabras_clave || []))];

            const prompt = `Eres un asistente experto en Vibe Coding educativo. Tu tarea es generar categorías y palabras clave para la siguiente pregunta y respuesta.
- Reutiliza las categorías existentes si es posible. Las categorías existentes son: [${existingCategories.join(', ')}].
- Reutiliza las palabras clave existentes si es posible. Las palabras clave existentes son: [${existingKeywords.join(', ')}].
- Crea nuevas categorías o palabras clave solo si es estrictamente necesario.
- Las categorías y palabras clave NO deben ser genéricas como "IA", "educación", "Vibe Coding", "pregunta", "respuesta". Deben ser específicas.

PREGUNTA: "${question}"
RESPUESTA: "${answer}"
`;
            const schema = {
                type: "OBJECT",
                properties: {
                    categorias: { type: "ARRAY", items: { type: "STRING" } },
                    palabras_clave: { type: "ARRAY", items: { type: "STRING" } }
                },
                required: ["categorias", "palabras_clave"]
            };

            try {
                const metadata = await callGemini(prompt, schema);
                const finalData = [{
                    pregunta: question,
                    respuesta: answer,
                    ...metadata
                }];

                showLoader(true, 'Añadiendo a la FAQ...');
                logSingleMessage('Añadiendo la nueva entrada a la hoja de cálculo...', 'info');

                const addResponse = await fetchFromGoogleScript('addData', finalData);
                if (addResponse && addResponse.status === 'success') {
                    logSingleMessage('¡Pregunta añadida con éxito!', 'success');
                    // Resetear campos
                    singleQuestion.value = '';
                    singleAnswer.value = '';
                    suggestedQuestion.value = '';
                    suggestedAnswer.value = '';
                    suggestionContainer.classList.add('hidden');
                } else {
                     logSingleMessage(`Error al añadir: ${addResponse ? addResponse.message : 'Respuesta nula'}`, 'error');
                }

            } catch (error) {
                logSingleMessage(`Error en el paso final: ${error.message}`, 'error');
            } finally {
                showLoader(false);
            }
        };


        // --- EVENT LISTENERS ---
        tabBtnBulk.addEventListener('click', () => switchTab('bulk'));
        tabBtnSingle.addEventListener('click', () => switchTab('single'));
        processBulkBtn.addEventListener('click', handleBulkProcess);
        suggestBtn.addEventListener('click', handleSuggestReformulation);
        acceptBtn.addEventListener('click', handleAcceptAndAdd);

        // --- INICIO ---
        document.addEventListener('DOMContentLoaded', initialize);

    </script>
</body>
</html>
